TCP/IP 四层模型 
TCP/IP 四层模型 是目前被广泛采用的一种模型,我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：
1. 应用层（Application Layer）：直接面向用户和应用程序，提供各种网络服务。它包含了用于特定应用的协议和服务，如 HTTP（HyperText Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。
示例：当在浏览器中输入一个 URL 并访问一个网页时，浏览器使用 HTTP 协议从 Web 服务器请求页面内容。
2. 传输层（Transport Layer）：(两个不同设备通信需要传数据，应用层把应用数据传输给传输层，传输层就负责提供网络支持负责"端到端"的可靠性）。提供端到端的通信服务，确保数据可靠传输。它负责分段数据、流量控制、错误检测和纠正。常见的传输层协议有 TCP 和 UDP。
示例：当发送一封电子邮件时，TCP 协议确保邮件从你的客户端可靠地传输到邮件服务器。
在传输层会有两个传输协议，分别是 TCP 和 UDP。
3. 网络层（Internet Layer）：负责在不同网络之间路由数据包，提供逻辑地址（IP 地址）和网络寻址功能。用于处理数据包的分组、转发和路由选择，确保数据可以从源端传输到目标端。（实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择）
常见协议：IPv4、IPv6、ICMP（Internet Control Message Protocol）。
示例：当访问一个网站时，网络层协议（如 IPv4）将你的请求从你的计算机通过多个路由器传输到目标服务器。
4. 网络接口层

TCP、UDP
TCP三次握手

SYN = Synchronize，核心作用是同步序列号（Sequence Number）
客户端                                          服务端
CLOSED                                         LISTEN
   |                                              |
   |------- 1. SYN (seq=x) -------------------->|
   |        "我想建立连接，我的初始序号是x"          |
SYN_SENT                                      SYN_RCVD
   |                                              |
   |<------ 2. SYN + ACK (seq=y, ack=x+1) ------|
   |        "同意连接，我的初始序号是y，            |
   |         已收到你的x"                         |
   |                                              |
   |------- 3. ACK (ack=y+1) ------------------>|
   |        "收到你的y，连接建立"                  |
ESTABLISHED                                  ESTABLISHED
1. 流程
● 第一次：客户端向服务器发送SYN (同步SEQ=x) 请求建立连接。此时，客户端等待服务器的响应。
● 第二次：当服务器收到 SYN 包后，向客户端发送一个 SYN-ACK (同步确认，SEQ=y,ACK=x+1) 包，表示同意建立连接并回传一个确认号。
● 第三次：当客户端收到服务器的 SYN-ACK 包后，发送一个 ACK (确认ACK=y+1， ACK = 收到的seq + 数据长度) 包给服务器，表示确认连接建立，完成3次握手。
2. 为什么不是2次？
● 如果是两次握手，可能会导致旧的 SYN 请求被服务器错误接受。
● CASE1: 假设客户端 A 发送了 SYN，但由于网络延迟或丢包，该 SYN 没有及时到达服务器，客户端 A 误以为服务器未响应，于是放弃连接。
● CASE2: 客户端重新发送新的SYN, 服务端正常响应到了发送SYN + ACK包，连接建立开始通信，但是延迟的 SYN服务器稍后又收到了，如果是两次握手，它也会直接建立新的连接，而客户端 A 可能早已关闭，不会再发送数据或者说又建立起了一个不需要的新的连接，导致服务器资源浪费。
3. 为什么不是4次？
● 三次握手已经保证了连接的可靠性，不需要额外的第四次握手。
● 如果使用四次握手（假设额外增加一次 ACK 确认），会导致额外的时延，但不会提升连接的可靠性，因此没有必要。
TCP 四次挥手
双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：

ACK (Acknowledgment) - 确认包，表示"我收到了你的数据"
FIN (Finish) - 结束包，表示"我没有数据要发送了，想要关闭连接"
1. 流程
● 第一次挥手（客户端→服务器）：客户端主动关闭连接，发送 FIN 报文段（FIN=1），表示客户端不再发送数据，但仍可接收数据。客户端进入 FIN-WAIT-1 状态。
● 第二次挥手（服务器→客户端）：服务器收到 FIN 后，发送 ACK 报文段（ACK=1，确认号 = 客户端 FIN 序号 + 1），表示已接收关闭请求。服务器进入 CLOSE-WAIT 状态，客户端收到 ACK 后进入 FIN-WAIT-2 状态。
● 第三次挥手（服务器→客户端）：服务器完成数据发送后，也发送 FIN 报文段（FIN=1），表示服务器不再发送数据。服务器进入 LAST-ACK 状态。
● 第四次挥手（客户端→服务器）：客户端收到服务器的 FIN 后，发送 ACK 报文段（ACK=1，确认号 = 服务器 FIN 序号 + 1），表示已接收关闭请求。客户端进入 TIME-WAIT 状态（等待 2MSL 确保服务器收到 ACK），服务器收到 ACK 后关闭连接（CLOSED 状态）。客户端等待超时后也关闭连接。
核心目的：确保双方都能正确终止数据传输，避免数据丢失
你可以看到，每个方向都需要一个 FIN 和一个 ACK，因此通常被称为四次挥手。
这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。
2. TCP 挥手为什么需要四次呢？为什么不是3次？
因为 TCP 是全双工通信协议，数据的发送和接收需要两次一来一回，也就是四次，来确保双方都能正确关闭连接。
● 第一次挥手：客户端表示数据发送完成了，准备关闭，你确认一下。
● 第二次挥手：服务端回话说 ok，我马上处理完数据，稍等。
● 第三次挥手：服务端表示处理完了，可以关闭了。
● 第四次挥手：客户端说好，进入 TIME_WAIT 状态，确保服务端关闭连接后，自己再关闭连接。

● 如果是三次挥手，意味着合并步骤确认接收到客户端释放请求+服务端发送释放请求
● 服务器在收到客户端FIN的同时直接发送 FIN，这会导致数据丢失的风险。
● 服务器可能仍有未发送完的数据，如果直接 FIN，则这些数据无法传输。
● 因此，需要先 ACK 客户端的 FIN，等数据发送完毕后，再发送 FIN，确保数据完整传输。

TCP和UDP的区别
TCP 和 UDP 都属于传输层协议，它们运行在网络层之上，为应用层提供端到端的数据传输服务。
TCP 是面向连接的，而 UDP 是无连接的。在数据传输开始之前，TCP 需要先建立连接，数据传输完成后，再断开连接。这个过程通常被称为“三次握手”、“四次挥手”。因此TCP 更可靠，它通过确认机制、重发机制等来保证数据的可靠传输；UDP 是无连接的，发送数据之前不需要建立连接，发送完毕也不需要断开，数据以数据报形式发送，因此数据包可能会丢失、重复、乱序。
适用场景：
● TCP： 适用于那些对数据准确性要求高于数据传输速度的场合。例如：网页浏览、电子邮件、文件传输（FTP）、远程控制、数据库链接。
● UDP： 适用于对速度要求高、可以容忍一定数据丢失的场合。例如：QQ 聊天、在线视频、网络语音电话、广播通信。

TCP可靠传输的原理
1. 连接方式
  a. 三次握手建立连接，四次挥手终止连接。
  b. TCP通过三次握手建立连接，确保双方通信能力正常，并用四次挥手终止连接，防止数据残留或资源浪费。
2. 数据分块、序号
  a. 发送端将数据分割为合适大小的报文段，每个段分配唯一序号，标识数据的字节顺序
  b. 接收端通过序号重组乱序到达的段，保证消息有序性，去掉重复序列号实现数据包去重
3. 校验和
  a. TCP首部和可以进行数据校验，如果收到的数据包校验和有差错，会丢弃这个包，不返回确认收到响应
4. 重传机制参考链接
    ■ 百度提前批，直接问了TCP的重传机制
  a. 基于计时器重传：每个数据包都有相应的计时器，一旦超过 RTO （重传超时时间）而没有收到 ACK，就重发该数据包。没收到 ACK 的数据包都会存在重传缓冲区里，等到 ACK 后，就从缓冲区里删除。
    ■ 缺点：效率低，假设数据包5丢失，数据包 6,7,8,9 都已经到达接收方，这个时候客户端就只能等服务器发送 ACK，注意对于包 6,7,8,9，服务器都不能发送 ACK，客户端他完全不知道丢了几个包，可能就悲观的认为，5 后面的数据包也都丢了，就重传这 5 个数据包，这就比较浪费了。
  b. 快速重传：服务器如果收到乱序的包，也给客户端回复 ACK，只不过是重复的 ACK。就拿刚刚的例子来说，收到乱序的包 6,7,8,9 时，服务器全都发 ACK = 5。这样，客户端就知道 5 发生了空缺。一般来说，如果客户端连续三次收到重复的 ACK，就会重传对应包，而不需要等到计时器超时。
    ■ 缺点：不知道要重传多少个包
  a. 带确认的重传：简单来讲就是在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了。
5. 流量控制接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。
  a. TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据
  b. 当接受方来不及处理数据，可以提醒发送方，降低的发送速率，使得接收方来得及接收，防止包丢失
  c. TCP利用滑动窗口机制，允许连续发送多个段，提升传输效率，同时动态调整发送速率。
6. 拥塞控制网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。
  a. 防止过多的数据注入网络中,使得网络过载
  b. 通过慢启动、拥塞避免、快速重传和快速恢复算法，动态调整发送速率以适应网络负载，防止网络瘫痪。
  c. 发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。
输入URL到页面展示发生了什么？
1. 根据url，用DNS域名解析系统，解析出IP地址
● 若该域名的 IP 地址已被缓存，浏览器会直接使用缓存的 IP 地址；若未缓存，则浏览器会向 DNS 服务器发送请求，获取该域名对应的 IP 地址。
2. 获取到ip后，浏览器和服务器3次握手建立TCP连接
● 在 HTTPS 请求中，浏览器还会通过 SSL/TLS 协议进行加密协商，确保通信的安全性。
3. 浏览器发送HTTP请求报文
● TCP 连接建立后，浏览器会发送 HTTP 请求到服务器。请求包括请求行、请求头和请求体。请求行包含请求方法（如 GET、POST）、请求的 URL 路径和 HTTP 版本。请求头包括浏览器信息、语言类型、缓存控制等信息。请求体则用于发送数据（如表单提交数据）
4. 服务器响应请求，返回要显示的HTML页面信息
● 服务器接收到请求后，首先会解析请求头并根据请求的 URL 路径决定如何处理。若请求的资源存在，服务器会读取该资源，进行一些业务处理、数据库查询或计算，然后生成响应数据。响应体也会包含状态行（status code:200请求成功），响应头部，响应数据。如果请求的是动态内容，服务器会调用应用程序逻辑（如 Java Servlet、Spring 控制器等）进行处理。
5. 浏览器显解析和渲染页面
● 浏览器接收到响应后，开始解析响应体中的 HTML 内容。在页面加载过程中，浏览器可能还会发送额外的请求来加载资源，如图片、字体、JavaScript 文件等。这些资源加载完成后，浏览器会继续更新页面内容。
6. 4次握手释放TCP连接
● 浏览器无需与服务器通信时，它可以主动关闭 TCP 连接，或等待服务器发送关闭请求。
● 域名解析协议用于将用户输入的域名解析为 IP 地址
DNS域名解析

1. 浏览器缓存解析
● 浏览器会先检查自身的 DNS 缓存，查看是否已经解析过该域名。
2. 操作系统缓存解析
● 操作系统维护了一个 DNS 解析缓存。如果在操作系统缓存中找到对应的解析结果，则直接返回 IP 地址。
3. 本地 DNS 服务器查询
● 向本地 DNS 服务器发送查询请求。本地 DNS 服务器会检查自身的缓存。
4. 向根域名服务器查询
● 本地 DNS 服务器会向根域名服务器发起查询请求。根域名服务器不会直接返回目标 IP 地址，而是返回负责.com 域的顶级域名服务器的地址。
5. 向顶级域名服务器查询
● 本地 DNS 服务器收到根服务器的响应后，向返回的 .com 顶级域名服务器发起查询请求。顶级域名服务器负责返回域名的权威 DNS 服务器的地址。
6. 进行权威 DNS 服务器解析
● 本地 DNS 服务器向域名的权威 DNS 服务器发起查询。权威 DNS 服务器返回对应的 IP 地址。
● 本地 DNS 服务器将解析结果返回给客户端，并将其存入缓存，以便下次查询时能更快响应。
7. 返回解析结果
● 本地 DNS 服务器将最终解析得到的 IP 地址返回给用户的计算机。然后，操作系统将解析结果存入缓存，并回给浏览器。浏览器使用该 IP 地址向目标服务器发起 HTTP/HTTPS 请求，建立连接并加载网页内容。
HTTP、HTTPS
HTTP状态码？
1. 成功响应
  a. 200 OK，代表请求成功
2. 重定向响应
  a. 301 Moved Permanently，代表请求的资源已被永久移动，浏览器会自动跳转到新 URL。
3. 客户端错误
  a. 400 Bad Request，代表请求格式错误或参数不正确，服务器无法理解请求。
  b. 403 Forbidden，代表服务器拒绝请求，客户端没有访问权限
  c. 404 Not Found，代表请求的资源不存在或 URL 书写错误。
4. 服务器错误
  a. 500 Internal Server Error，代表服务器内部错误
  b. 502 Bad Gateway，代表服务器作为网关或代理时，接收到无效响应。
  c. 503 Service Unavailable，代表服务器暂时不可用，通常是维护或过载导致的。
  d. 504 Gateway Timeout，代表服务器作为网关时，未能及时收到上游服务器的响应。
HTTP 有哪些请求方式？
HTTP 协议定义了多种请求方式，用以指示请求的目的。常见的请求方式有 GET、POST、DELETE、PUT。

● GET：请求检索指定的资源。应该只用于获取数据，并且是幂等的，即多次执行相同的 GET 请求应该返回相同的结果，并且不会改变资源的状态。
● POST：向指定资源提交数据，请求服务器进行处理（如提交表单或上传文件）。数据被包含在请求体中。可能会创建新的资源或修改现有资源。
● DELETE：删除指定的资源。
● PUT：用于替换指定的资源。如果指定的资源不存在，创建一个新资源。
HTTP 与 HTTPS 有哪些区别？
HTTP 和 HTTPS 都是 Web 传输协议，用于在客户端（浏览器）和服务器之间通信。
1. 安全性（核心区别）
  a. HTTP是超文本传输协议，它通过明文传输数据，通信内容容易被窃听、篡改或伪造
  b. HTTPS在 HTTP 的基础上加入了 SSL/TLS 加密层，确保数据传输的安全性和完整性。
2. 端口号和前缀
  a. HTTP 使用默认端口 80，前缀是http
  b. HTTPS 使用默认端口 443，前缀是https，区别在于 HTTPS 需要额外的 SSL/TLS 握手过程。
SSL/TLS 的工作原理？（最高频）

1-6是非对称加密，7是对称加密因为非对称的资源消耗很大，生成的会话密钥也仅基于当前会话，所以直接用会话密钥即可
TLS握手的核心是安全地协商出一个对称加密的会话密钥，同时验证通信双方的身份（主要是服务端）。
TLS 握手阶段（RSA 密钥交换）
1. 客户端发起请求（ClientHello）
  a. 客户端向服务端发送： 
    ■ 支持的TLS版本（如TLS 1.2/1.3）、加密套件列表（如RSA-AES-GCM）； 
    ■ 随机数A（client_random，32字节，包含时间戳和随机值，用于后续生成会话密钥）； 
    ■ （可选）客户端证书请求（如双向认证场景）。 
2. 服务端响应（ServerHello + 证书）
  a. 服务端确认： 
    ■ 选择双方都支持的TLS版本和加密套件（如确定用RSA密钥交换 + AES对称加密）； 
    ■ 返回随机数B（server_random，32字节，与随机数A共同参与会话密钥生成）； 
  b. 服务端发送CA签名的证书：包含服务端公钥、域名、有效期等信息，用于客户端验证服务端身份。 
3. 客户端验证证书并发送预主密钥
  a. 客户端验证证书有效性： 
    ■ 检查证书是否由可信CA颁发（操作系统/浏览器内置CA根证书）； 
    ■ 验证证书签名（用CA公钥解密证书上的签名，对比证书内容的哈希值，确保证书未被篡改）； 
    ■ 确认证书域名与当前访问域名一致（防止钓鱼）。 
  b. 生成预主密钥（pre-master secret）：一个48字节的随机数，用于最终生成会话密钥； 
  c. 用服务端公钥加密预主密钥，发送给服务端（**非对称加密的核心作用：仅服务端能用私钥解密）。 
4. 双方生成会话密钥
  a. 服务端用私钥解密得到预主密钥； 
  b. 客户端和服务端分别通过相同的算法，用 预主密钥 + 随机数A + 随机数B 生成会话密钥（master secret），再衍生出实际用于加密的对称密钥（如数据加密密钥、MAC验证密钥等）。 
5. 加密通信阶段（对称加密）
会话密钥协商完成后，进入数据传输阶段： 
● 对称加密：使用协商好的会话密钥（如AES算法）加密实际数据，效率远高于非对称加密； 
● 完整性校验：通过消息认证码（MAC）或AEAD（Authenticated Encryption with Associated Data，如GCM模式）确保数据未被篡改或伪造； 
● 防重放攻击：除了随机数A/B，TLS还会通过序列号（每个加密消息递增的编号）防止攻击者重复发送旧消息。
